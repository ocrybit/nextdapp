{"ast":null,"code":"import { hasPath, complement, isNil } from \"ramda\";\nconst xNil = complement(isNil);\n\nconst {\n  parse\n} = require(\"url\");\n\nrequire(\"isomorphic-fetch\");\n\nconst toParams = params => Object.keys(params).map(key => {\n  return encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]);\n}).join(\"&\");\n\nimport conf from \"nd/conf\";\nimport ns from \"nd/core/ns\";\nconst $ = ns(\"account\");\n\nconst NodeRSA = require(\"node-rsa\");\n\nconst toRSAPublic = key => `-----BEGIN PUBLIC KEY-----\\n${key}\\n-----END PUBLIC KEY-----`;\n\nconst toRSAPrivate = key => `-----BEGIN RSA PRIVATE KEY-----\\n${key}\\n-----END RSA PRIVATE KEY-----`;\n\nexport default (async (req, res) => {\n  const key = new NodeRSA(toRSAPublic(conf.rsa.public));\n  key.importKey(toRSAPrivate(process.env.RSA_PRIVATE.replace(/\\\\n/g, \"\\n\")), \"private\");\n  const {\n    client_id\n  } = conf.alis;\n  const base64 = new Buffer(client_id + \":\" + process.env.ALIS_CLIENT_SECRET).toString(\"base64\");\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n  res.setHeader(\"Content-Type\", \"application/json\");\n  const {\n    query\n  } = parse(req.url, true);\n\n  try {\n    const r = await fetch(\"https://alis.to/oauth2/token\", {\n      headers: {\n        Authorization: \"Basic \" + base64,\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      method: \"POST\",\n      body: toParams({\n        grant_type: \"authorization_code\",\n        code: query.code,\n        redirect_uri: conf.alis.redirect_uri,\n        code_verifier: query.verifier\n      })\n    }).then(r => r.json());\n    console.log(r);\n\n    if (xNil(r.error_message)) {\n      res.end(JSON.stringify(r));\n    } else {\n      try {\n        let op = {\n          headers: {\n            Authorization: r.access_token,\n            \"Content-Type\": \"application/json; charset=utf-8\"\n          }\n        };\n        let user = JSON.parse(unescape(await fetch(\"https://alis.to/oauth2api/me/info\", op).then(r => r.text())));\n        const json_str = JSON.stringify({\n          uid: query.uid,\n          token: r.access_token,\n          refresh: r.refresh_token,\n          user: user,\n          crypt_id: query.crypt_id\n        });\n        const obj = key.encrypt(json_str, \"base64\");\n        const sign = key.sign(json_str, \"base64\", \"utf8\");\n        const base_url = hasPath([\"functions\", \"base_url\"])(conf) ? conf.functions.base_url : `https://${conf.fb.region}-${conf.fb.id}.cloudfunctions.net`;\n        const href = `${base_url}/${$(\"login\")}?data=${encodeURIComponent(obj)}&signature=${encodeURIComponent(sign)}`;\n        const reg = await fetch(href).then(r => r.json());\n        const json_str_reg = key.decrypt(reg.data, \"utf8\");\n        const verify = key.verify(json_str_reg, reg.signature, \"utf8\", \"base64\");\n        const json = JSON.parse(json_str_reg);\n\n        if (verify) {\n          res.end(JSON.stringify(json));\n        } else {\n          res.end(JSON.stringify({\n            err: \"signature invalid\"\n          }));\n        }\n      } catch (e) {\n        console.log(e);\n        res.end(JSON.stringify(e));\n      }\n    }\n  } catch (e) {\n    res.send({\n      err: \"unknown err\"\n    });\n  }\n});","map":{"version":3,"sources":["/home/basque/hide/next-dapp/nd/account/api/alis-oauth.js"],"names":["hasPath","complement","isNil","xNil","parse","require","toParams","params","Object","keys","map","key","encodeURIComponent","join","conf","ns","$","NodeRSA","toRSAPublic","toRSAPrivate","req","res","rsa","public","importKey","process","env","RSA_PRIVATE","replace","client_id","alis","base64","Buffer","ALIS_CLIENT_SECRET","toString","setHeader","query","url","r","fetch","headers","Authorization","method","body","grant_type","code","redirect_uri","code_verifier","verifier","then","json","console","log","error_message","end","JSON","stringify","op","access_token","user","unescape","text","json_str","uid","token","refresh","refresh_token","crypt_id","obj","encrypt","sign","base_url","functions","fb","region","id","href","reg","json_str_reg","decrypt","data","verify","signature","err","e","send"],"mappings":"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","sourcesContent":["import { hasPath, complement, isNil } from \"ramda\"\nconst xNil = complement(isNil)\nconst { parse } = require(\"url\")\nrequire(\"isomorphic-fetch\")\nconst toParams = params =>\n  Object.keys(params)\n    .map(key => {\n      return encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key])\n    })\n    .join(\"&\")\n\nimport conf from \"nd/conf\"\nimport ns from \"nd/core/ns\"\nconst $ = ns(\"account\")\nconst NodeRSA = require(\"node-rsa\")\nconst toRSAPublic = key =>\n  `-----BEGIN PUBLIC KEY-----\\n${key}\\n-----END PUBLIC KEY-----`\nconst toRSAPrivate = key =>\n  `-----BEGIN RSA PRIVATE KEY-----\\n${key}\\n-----END RSA PRIVATE KEY-----`\nexport default async (req, res) => {\n  const key = new NodeRSA(toRSAPublic(conf.rsa.public))\n  key.importKey(\n    toRSAPrivate(process.env.RSA_PRIVATE.replace(/\\\\n/g, \"\\n\")),\n    \"private\"\n  )\n  const { client_id } = conf.alis\n  const base64 = new Buffer(\n    client_id + \":\" + process.env.ALIS_CLIENT_SECRET\n  ).toString(\"base64\")\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\")\n  res.setHeader(\"Content-Type\", \"application/json\")\n  const { query } = parse(req.url, true)\n  try {\n    const r = await fetch(\"https://alis.to/oauth2/token\", {\n      headers: {\n        Authorization: \"Basic \" + base64,\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      method: \"POST\",\n      body: toParams({\n        grant_type: \"authorization_code\",\n        code: query.code,\n        redirect_uri: conf.alis.redirect_uri,\n        code_verifier: query.verifier\n      })\n    }).then(r => r.json())\n    console.log(r)\n    if (xNil(r.error_message)) {\n      res.end(JSON.stringify(r))\n    } else {\n      try {\n        let op = {\n          headers: {\n            Authorization: r.access_token,\n            \"Content-Type\": \"application/json; charset=utf-8\"\n          }\n        }\n        let user = JSON.parse(\n          unescape(\n            await fetch(\"https://alis.to/oauth2api/me/info\", op).then(r =>\n              r.text()\n            )\n          )\n        )\n        const json_str = JSON.stringify({\n          uid: query.uid,\n          token: r.access_token,\n          refresh: r.refresh_token,\n          user: user,\n          crypt_id: query.crypt_id\n        })\n        const obj = key.encrypt(json_str, \"base64\")\n        const sign = key.sign(json_str, \"base64\", \"utf8\")\n        const base_url = hasPath([\"functions\", \"base_url\"])(conf)\n          ? conf.functions.base_url\n          : `https://${conf.fb.region}-${conf.fb.id}.cloudfunctions.net`\n        const href = `${base_url}/${$(\"login\")}?data=${encodeURIComponent(\n          obj\n        )}&signature=${encodeURIComponent(sign)}`\n        const reg = await fetch(href).then(r => r.json())\n        const json_str_reg = key.decrypt(reg.data, \"utf8\")\n        const verify = key.verify(json_str_reg, reg.signature, \"utf8\", \"base64\")\n        const json = JSON.parse(json_str_reg)\n        if (verify) {\n          res.end(JSON.stringify(json))\n        } else {\n          res.end(JSON.stringify({ err: \"signature invalid\" }))\n        }\n      } catch (e) {\n        console.log(e)\n        res.end(JSON.stringify(e))\n      }\n    }\n  } catch (e) {\n    res.send({ err: \"unknown err\" })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}