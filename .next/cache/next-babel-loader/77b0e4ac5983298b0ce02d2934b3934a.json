{"ast":null,"code":"import { is, has, assocPath, isNil, forEach } from \"ramda\";\nimport { useRecoilTransactionObserver_UNSTABLE, useRecoilCallback, atom, useRecoilState } from \"recoil\";\nimport { atoms, funcs } from \"nd\";\n\nconst addFuncProps = (arr, obj, dup_funcs) => {\n  for (const v of arr || []) {\n    if (!has(v)(atoms) && !has(v)(funcs)) {\n      atoms[v] = atom({\n        key: v,\n        default: null\n      });\n    } else if (has(v)(funcs) && isNil(dup_funcs[v])) {\n      dup_funcs[v] = true;\n      addFuncProps(funcs[v].props, obj, dup_funcs);\n    }\n\n    if (has(v)(atoms)) {\n      const hook = useRecoilState(atoms[v]);\n      obj[v] = {\n        set: hook[1],\n        get: hook[0]\n      };\n    }\n  }\n};\n\nconst bind_states = arr => {\n  let obj = {};\n  let dup_funcs = {};\n  addFuncProps(arr, obj, dup_funcs);\n  return obj;\n};\n\nexport default (_states => {\n  const binder = bind_states(_states);\n  const updated = {};\n  const setter = useRecoilCallback(({\n    snapshot: {\n      getPromise\n    },\n    set\n  }) => async ({\n    name,\n    val\n  }) => {\n    name = is(Array)(name) ? name.length === 1 ? name[0] : name.length === 0 ? null : name : name;\n\n    if (is(Array)(name)) {\n      if (!has(name[0])(atoms)) atoms[name[0]] = atom({\n        key: name[0],\n        default: {}\n      });\n      const new_val = assocPath(name.slice(1), val)(await getPromise(atoms[name[0]]));\n      set(atoms[name[0]], new_val);\n      updated[name[0]] = new_val;\n    } else {\n      const states = isNil(name) ? val : {\n        [name]: val\n      };\n\n      for (const k in states) {\n        if (!has(k)(atoms)) atoms[k] = atom({\n          key: k,\n          default: null\n        });\n        set(atoms[k], states[k]);\n        updated[k] = states[k];\n      }\n    }\n  });\n  useRecoilTransactionObserver_UNSTABLE(({\n    snapshot\n  }) => {\n    for (let k in atoms) {\n      updated[k] = snapshot.getLoadable(atoms[k]).contents;\n    }\n  });\n  const getter = useRecoilCallback(({\n    snapshot: {\n      getLoadable\n    }\n  }) => ({\n    name\n  }) => has(name)(atoms) ? isNil(updated[name]) ? getLoadable(atoms[name]).contents : updated[name] : null);\n\n  const set = (val, name) => setter({\n    val,\n    name\n  });\n\n  const get = name => getter({\n    name\n  });\n\n  return {\n    binder,\n    set,\n    get\n  };\n});","map":{"version":3,"sources":["/home/basque/hide/next-dapp/nd/core/setter.js"],"names":["is","has","assocPath","isNil","forEach","useRecoilTransactionObserver_UNSTABLE","useRecoilCallback","atom","useRecoilState","atoms","funcs","addFuncProps","arr","obj","dup_funcs","v","key","default","props","hook","set","get","bind_states","_states","binder","updated","setter","snapshot","getPromise","name","val","Array","length","new_val","slice","states","k","getLoadable","contents","getter"],"mappings":"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","sourcesContent":["import { is, has, assocPath, isNil, forEach } from \"ramda\"\nimport {\n  useRecoilTransactionObserver_UNSTABLE,\n  useRecoilCallback,\n  atom,\n  useRecoilState\n} from \"recoil\"\nimport { atoms, funcs } from \"nd\"\n\nconst addFuncProps = (arr, obj, dup_funcs) => {\n  for (const v of arr || []) {\n    if (!has(v)(atoms) && !has(v)(funcs)) {\n      atoms[v] = atom({\n        key: v,\n        default: null\n      })\n    } else if (has(v)(funcs) && isNil(dup_funcs[v])) {\n      dup_funcs[v] = true\n      addFuncProps(funcs[v].props, obj, dup_funcs)\n    }\n    if (has(v)(atoms)) {\n      const hook = useRecoilState(atoms[v])\n      obj[v] = { set: hook[1], get: hook[0] }\n    }\n  }\n}\nconst bind_states = arr => {\n  let obj = {}\n  let dup_funcs = {}\n  addFuncProps(arr, obj, dup_funcs)\n  return obj\n}\n\nexport default _states => {\n  const binder = bind_states(_states)\n  const updated = {}\n  const setter = useRecoilCallback(\n    ({ snapshot: { getPromise }, set }) => async ({ name, val }) => {\n      name = is(Array)(name)\n        ? name.length === 1\n          ? name[0]\n          : name.length === 0\n          ? null\n          : name\n        : name\n      if (is(Array)(name)) {\n        if (!has(name[0])(atoms))\n          atoms[name[0]] = atom({ key: name[0], default: {} })\n        const new_val = assocPath(\n          name.slice(1),\n          val\n        )(await getPromise(atoms[name[0]]))\n        set(atoms[name[0]], new_val)\n        updated[name[0]] = new_val\n      } else {\n        const states = isNil(name) ? val : { [name]: val }\n        for (const k in states) {\n          if (!has(k)(atoms)) atoms[k] = atom({ key: k, default: null })\n          set(atoms[k], states[k])\n          updated[k] = states[k]\n        }\n      }\n    }\n  )\n  useRecoilTransactionObserver_UNSTABLE(({ snapshot }) => {\n    for (let k in atoms) {\n      updated[k] = snapshot.getLoadable(atoms[k]).contents\n    }\n  })\n  const getter = useRecoilCallback(\n    ({ snapshot: { getLoadable } }) => ({ name }) =>\n      has(name)(atoms)\n        ? isNil(updated[name])\n          ? getLoadable(atoms[name]).contents\n          : updated[name]\n        : null\n  )\n  const set = (val, name) => setter({ val, name })\n  const get = name => getter({ name })\n  return { binder, set, get }\n}\n"]},"metadata":{},"sourceType":"module"}