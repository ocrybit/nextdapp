{"ast":null,"code":"var _jsxFileName = \"/home/basque/hide/next-dapp/nd/core/bind.js\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from \"react\";\nimport { global, conf, funcs, atoms } from \"nd\";\nimport { selector, useRecoilValue, atom } from \"recoil\";\nimport { keys, compose, mergeLeft, has, assocPath, isNil, mapObjIndexed, map, is, pick, complement, forEach, both, cond } from \"ramda\";\nimport { withRouter } from \"next/router\";\nimport setter from \"./setter\";\nimport func from \"./func\";\nconst isNonArrayObj = both(is(Object), complement(is(Array)));\nexport default ((Component, _arr = [], track) => {\n  const arr = is(Array)(_arr) ? _arr : is(Array)(Component.props) ? [] : [];\n  return withRouter(props => {\n    let _props = [];\n    let _funcs = [];\n    let _tracks = {};\n\n    const initAtom = (v, init) => {\n      if (has(v)(atoms)) {\n        _props.push(v);\n      } else if (has(v)(funcs)) {\n        _funcs.push(v);\n      } else {\n        _props.push(v);\n\n        atoms[v] = atom({\n          key: v,\n          default: init\n        });\n        console.log(`new atom created...${v}`);\n      }\n    };\n\n    forEach(v => {\n      if (isNonArrayObj(v)) {\n        const selectors = {};\n        mapObjIndexed((v2, key) => {\n          if (is(Function)(v2)) {\n            const fn = func(v2);\n            funcs[key] = fn;\n\n            _funcs.push(key);\n          } else if (is(Array)(v2) && is(Function)(v2[0])) {\n            const fn = func(v2[1], v2[0]);\n            funcs[key] = fn;\n\n            _funcs.push(key);\n          } else if (is(Function)(v2.get)) {\n            let sel;\n\n            if (!has(key)(atoms)) {\n              sel = selector({\n                key: key,\n                get: v2.get(atoms)\n              });\n              atoms[key] = sel;\n            } else {\n              sel = atoms[key];\n            }\n\n            selectors[key] = sel;\n          } else {\n            initAtom(key, v2);\n          }\n        })(v);\n        _tracks = mergeLeft(selectors, _tracks);\n      } else if (is(String)(v)) {\n        initAtom(v, null);\n      } else {\n        console.log(`unknow binding type`);\n        console.log(v);\n      }\n    })(arr);\n    const {\n      set,\n      get,\n      binder\n    } = setter(_props);\n    let tracker = null;\n\n    if (is(String)(track)) {\n      const track_name = `${track}$tracker`;\n      const diff_name = `${track_name}_diff`;\n      const prev_name = `${track_name}_prev`;\n\n      if (!has(diff_name)(atoms)) {\n        atoms[diff_name] = atom({\n          key: diff_name,\n          default: []\n        });\n        atoms[prev_name] = atom({\n          key: prev_name,\n          default: {}\n        });\n      }\n\n      tracker = {\n        diff: atoms[diff_name],\n        prev: atoms[prev_name]\n      };\n    }\n\n    const $ = map(v => v.get)(binder);\n    return __jsx(Component, _extends({\n      tracker: tracker,\n      init: _arr => {\n        forEach(v => {\n          if (isNonArrayObj(v)) {\n            const selectors = {};\n            mapObjIndexed((v2, key) => {\n              if (is(Function)(v2)) {\n                const fn = func(v2);\n                funcs[key] = fn;\n\n                _funcs.push(key);\n              } else if (is(Array)(v2) && is(Function)(v2[0])) {\n                const fn = func(v2[1], v2[0]);\n                funcs[key] = fn;\n\n                _funcs.push(key);\n              } else {\n                console.log(`not a function`);\n              }\n            })(v);\n          } else if (is(String)(v)) {\n            if (has(v)(atoms)) {\n              console.log(`this is atom`);\n            } else if (has(v)(funcs)) {\n              _funcs.push(v);\n            } else {\n              console.log(`${v} doesn't exist`);\n            }\n          } else {\n            console.log(`unknow binding type`);\n            console.log(v);\n          }\n        })(_arr || []);\n        return mapObjIndexed((v, k) => v())(pick(_funcs)(funcs));\n      },\n      $: $,\n      conf: conf,\n      global: global,\n      set: set,\n      get: get\n    }, mapObjIndexed((v, k) => useRecoilValue(v))(_tracks), $, props, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 99,\n        columnNumber: 7\n      }\n    }));\n  });\n});","map":{"version":3,"sources":["/home/basque/hide/next-dapp/nd/core/bind.js"],"names":["React","global","conf","funcs","atoms","selector","useRecoilValue","atom","keys","compose","mergeLeft","has","assocPath","isNil","mapObjIndexed","map","is","pick","complement","forEach","both","cond","withRouter","setter","func","isNonArrayObj","Object","Array","Component","_arr","track","arr","props","_props","_funcs","_tracks","initAtom","v","init","push","key","default","console","log","selectors","v2","Function","fn","get","sel","String","set","binder","tracker","track_name","diff_name","prev_name","diff","prev","$","k"],"mappings":"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","sourcesContent":["import React from \"react\"\nimport { global, conf, funcs, atoms } from \"nd\"\n\nimport { selector, useRecoilValue, atom } from \"recoil\"\n\nimport {\n  keys,\n  compose,\n  mergeLeft,\n  has,\n  assocPath,\n  isNil,\n  mapObjIndexed,\n  map,\n  is,\n  pick,\n  complement,\n  forEach,\n  both,\n  cond\n} from \"ramda\"\n\nimport { withRouter } from \"next/router\"\nimport setter from \"./setter\"\nimport func from \"./func\"\n\nconst isNonArrayObj = both(is(Object), complement(is(Array)))\n\nexport default (Component, _arr = [], track) => {\n  const arr = is(Array)(_arr) ? _arr : is(Array)(Component.props) ? [] : []\n  return withRouter(props => {\n    let _props = []\n    let _funcs = []\n    let _tracks = {}\n    const initAtom = (v, init) => {\n      if (has(v)(atoms)) {\n        _props.push(v)\n      } else if (has(v)(funcs)) {\n        _funcs.push(v)\n      } else {\n        _props.push(v)\n        atoms[v] = atom({\n          key: v,\n          default: init\n        })\n        console.log(`new atom created...${v}`)\n      }\n    }\n    forEach(v => {\n      if (isNonArrayObj(v)) {\n        const selectors = {}\n        mapObjIndexed((v2, key) => {\n          if (is(Function)(v2)) {\n            const fn = func(v2)\n            funcs[key] = fn\n            _funcs.push(key)\n          } else if (is(Array)(v2) && is(Function)(v2[0])) {\n            const fn = func(v2[1], v2[0])\n            funcs[key] = fn\n            _funcs.push(key)\n          } else if (is(Function)(v2.get)) {\n            let sel\n            if (!has(key)(atoms)) {\n              sel = selector({\n                key: key,\n                get: v2.get(atoms)\n              })\n              atoms[key] = sel\n            } else {\n              sel = atoms[key]\n            }\n            selectors[key] = sel\n          } else {\n            initAtom(key, v2)\n          }\n        })(v)\n        _tracks = mergeLeft(selectors, _tracks)\n      } else if (is(String)(v)) {\n        initAtom(v, null)\n      } else {\n        console.log(`unknow binding type`)\n        console.log(v)\n      }\n    })(arr)\n    const { set, get, binder } = setter(_props)\n    let tracker = null\n    if (is(String)(track)) {\n      const track_name = `${track}$tracker`\n      const diff_name = `${track_name}_diff`\n      const prev_name = `${track_name}_prev`\n      if (!has(diff_name)(atoms)) {\n        atoms[diff_name] = atom({ key: diff_name, default: [] })\n        atoms[prev_name] = atom({ key: prev_name, default: {} })\n      }\n      tracker = { diff: atoms[diff_name], prev: atoms[prev_name] }\n    }\n    const $ = map(v => v.get)(binder)\n    return (\n      <Component\n        tracker={tracker}\n        init={_arr => {\n          forEach(v => {\n            if (isNonArrayObj(v)) {\n              const selectors = {}\n              mapObjIndexed((v2, key) => {\n                if (is(Function)(v2)) {\n                  const fn = func(v2)\n                  funcs[key] = fn\n                  _funcs.push(key)\n                } else if (is(Array)(v2) && is(Function)(v2[0])) {\n                  const fn = func(v2[1], v2[0])\n                  funcs[key] = fn\n                  _funcs.push(key)\n                } else {\n                  console.log(`not a function`)\n                }\n              })(v)\n            } else if (is(String)(v)) {\n              if (has(v)(atoms)) {\n                console.log(`this is atom`)\n              } else if (has(v)(funcs)) {\n                _funcs.push(v)\n              } else {\n                console.log(`${v} doesn't exist`)\n              }\n            } else {\n              console.log(`unknow binding type`)\n              console.log(v)\n            }\n          })(_arr || [])\n          return mapObjIndexed((v, k) => v())(pick(_funcs)(funcs))\n        }}\n        $={$}\n        conf={conf}\n        global={global}\n        set={set}\n        get={get}\n        {...mapObjIndexed((v, k) => useRecoilValue(v))(_tracks)}\n        {...$}\n        {...props}\n      />\n    )\n  })\n}\n"]},"metadata":{},"sourceType":"module"}