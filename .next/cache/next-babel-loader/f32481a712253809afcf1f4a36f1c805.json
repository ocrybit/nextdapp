{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { is, has, assocPath, isNil, forEach } from \"ramda\";\nimport { useRecoilTransactionObserver_UNSTABLE, useRecoilCallback, atom, useRecoilState } from \"recoil\";\nimport { atoms, funcs } from \"nd\";\n\nvar addFuncProps = function addFuncProps(arr, obj, dup_funcs) {\n  _s();\n\n  var _iterator = _createForOfIteratorHelper(arr || []),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var v = _step.value;\n\n      if (!has(v)(atoms) && !has(v)(funcs)) {\n        atoms[v] = atom({\n          key: v,\n          \"default\": null\n        });\n      } else if (has(v)(funcs) && isNil(dup_funcs[v])) {\n        dup_funcs[v] = true;\n        addFuncProps(funcs[v].props, obj, dup_funcs);\n      }\n\n      if (has(v)(atoms)) {\n        var hook = useRecoilState(atoms[v]);\n        obj[v] = {\n          set: hook[1],\n          get: hook[0]\n        };\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\n_s(addFuncProps, \"1zW77sfxbNgfZrR5zMZ0thP2U1w=\", false, function () {\n  return [useRecoilState];\n});\n\nvar bind_states = function bind_states(arr) {\n  var obj = {};\n  var dup_funcs = {};\n  addFuncProps(arr, obj, dup_funcs);\n  return obj;\n};\n\nexport default _s2(function (_states) {\n  _s2();\n\n  var binder = bind_states(_states);\n  var updated = {};\n  var setter = useRecoilCallback(function (_ref) {\n    var getPromise = _ref.snapshot.getPromise,\n        set = _ref.set;\n    return /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n        var name, val, new_val, states, k;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                name = _ref2.name, val = _ref2.val;\n                name = is(Array)(name) ? name.length === 1 ? name[0] : name.length === 0 ? null : name : name;\n\n                if (!is(Array)(name)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                if (!has(name[0])(atoms)) atoms[name[0]] = atom({\n                  key: name[0],\n                  \"default\": {}\n                });\n                _context.t0 = assocPath(name.slice(1), val);\n                _context.next = 7;\n                return getPromise(atoms[name[0]]);\n\n              case 7:\n                _context.t1 = _context.sent;\n                new_val = (0, _context.t0)(_context.t1);\n                set(atoms[name[0]], new_val);\n                updated[name[0]] = new_val;\n                _context.next = 15;\n                break;\n\n              case 13:\n                states = isNil(name) ? val : _defineProperty({}, name, val);\n\n                for (k in states) {\n                  if (!has(k)(atoms)) atoms[k] = atom({\n                    key: k,\n                    \"default\": null\n                  });\n                  set(atoms[k], states[k]);\n                  updated[k] = states[k];\n                }\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n  });\n  useRecoilTransactionObserver_UNSTABLE(function (_ref5) {\n    var snapshot = _ref5.snapshot;\n\n    for (var k in atoms) {\n      updated[k] = snapshot.getLoadable(atoms[k]).contents;\n    }\n  });\n  var getter = useRecoilCallback(function (_ref6) {\n    var getLoadable = _ref6.snapshot.getLoadable;\n    return function (_ref7) {\n      var name = _ref7.name;\n      return has(name)(atoms) ? isNil(updated[name]) ? getLoadable(atoms[name]).contents : updated[name] : null;\n    };\n  });\n\n  var set = function set(val, name) {\n    return setter({\n      val: val,\n      name: name\n    });\n  };\n\n  var get = function get(name) {\n    return getter({\n      name: name\n    });\n  };\n\n  return {\n    binder: binder,\n    set: set,\n    get: get\n  };\n}, \"xSZSy+KeRmAcX0NKMCJuMpbr4V4=\", false, function () {\n  return [useRecoilCallback, useRecoilTransactionObserver_UNSTABLE, useRecoilCallback];\n});","map":{"version":3,"sources":["/home/basque/hide/next-dapp/nd/core/setter.js"],"names":["is","has","assocPath","isNil","forEach","useRecoilTransactionObserver_UNSTABLE","useRecoilCallback","atom","useRecoilState","atoms","funcs","addFuncProps","arr","obj","dup_funcs","v","key","props","hook","set","get","bind_states","_states","binder","updated","setter","getPromise","snapshot","name","val","Array","length","slice","new_val","states","k","getLoadable","contents","getter"],"mappings":"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","sourcesContent":["import { is, has, assocPath, isNil, forEach } from \"ramda\"\nimport {\n  useRecoilTransactionObserver_UNSTABLE,\n  useRecoilCallback,\n  atom,\n  useRecoilState\n} from \"recoil\"\nimport { atoms, funcs } from \"nd\"\n\nconst addFuncProps = (arr, obj, dup_funcs) => {\n  for (const v of arr || []) {\n    if (!has(v)(atoms) && !has(v)(funcs)) {\n      atoms[v] = atom({\n        key: v,\n        default: null\n      })\n    } else if (has(v)(funcs) && isNil(dup_funcs[v])) {\n      dup_funcs[v] = true\n      addFuncProps(funcs[v].props, obj, dup_funcs)\n    }\n    if (has(v)(atoms)) {\n      const hook = useRecoilState(atoms[v])\n      obj[v] = { set: hook[1], get: hook[0] }\n    }\n  }\n}\nconst bind_states = arr => {\n  let obj = {}\n  let dup_funcs = {}\n  addFuncProps(arr, obj, dup_funcs)\n  return obj\n}\n\nexport default _states => {\n  const binder = bind_states(_states)\n  const updated = {}\n  const setter = useRecoilCallback(\n    ({ snapshot: { getPromise }, set }) => async ({ name, val }) => {\n      name = is(Array)(name)\n        ? name.length === 1\n          ? name[0]\n          : name.length === 0\n          ? null\n          : name\n        : name\n      if (is(Array)(name)) {\n        if (!has(name[0])(atoms))\n          atoms[name[0]] = atom({ key: name[0], default: {} })\n        const new_val = assocPath(\n          name.slice(1),\n          val\n        )(await getPromise(atoms[name[0]]))\n        set(atoms[name[0]], new_val)\n        updated[name[0]] = new_val\n      } else {\n        const states = isNil(name) ? val : { [name]: val }\n        for (const k in states) {\n          if (!has(k)(atoms)) atoms[k] = atom({ key: k, default: null })\n          set(atoms[k], states[k])\n          updated[k] = states[k]\n        }\n      }\n    }\n  )\n  useRecoilTransactionObserver_UNSTABLE(({ snapshot }) => {\n    for (let k in atoms) {\n      updated[k] = snapshot.getLoadable(atoms[k]).contents\n    }\n  })\n  const getter = useRecoilCallback(\n    ({ snapshot: { getLoadable } }) => ({ name }) =>\n      has(name)(atoms)\n        ? isNil(updated[name])\n          ? getLoadable(atoms[name]).contents\n          : updated[name]\n        : null\n  )\n  const set = (val, name) => setter({ val, name })\n  const get = name => getter({ name })\n  return { binder, set, get }\n}\n"]},"metadata":{},"sourceType":"module"}